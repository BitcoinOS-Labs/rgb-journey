use curve25519_dalek::{ristretto::RistrettoPoint, scalar::Scalar, traits::Identity};
use rand::rngs::OsRng;
use sha2::Sha512;
use std::ops::{Mul, Sub};

/// Cryptographic operator for the mint (Bob)
pub struct MintCrypto {
    // the secret key for a particular Ecash denomination
    secret: Scalar,
    // the public key for the Ecash denomination specific to the secret key above
    public: RistrettoPoint,
}

impl MintCrypto {
    pub fn new() -> Self {
        // generate a secret key and store
        let secret = Scalar::random(&mut OsRng);
        // generate the public key
        let public = RistrettoPoint::identity().mul(&secret);

        Self { secret, public }
    }

    /// Generate a blinded token to return to Alice
    pub fn blinded_token(&self, blinded_message: RistrettoPoint) -> RistrettoPoint {
        blinded_message.mul(self.secret)
    }

    /// Prove that the unblinded token is valid
    pub fn proof(&self, unblinded_token: UnblindedToken) -> bool {
        // Compute the point on elliptic curve
        let hash_to_curve =
            RistrettoPoint::hash_from_bytes::<Sha512>(unblinded_token.secret.as_bytes());

        self.secret.mul(hash_to_curve) == unblinded_token.proof
    }

    pub fn public_key(&self) -> RistrettoPoint {
        self.public
    }
}

impl Default for MintCrypto {
    fn default() -> Self {
        Self::new()
    }
}

/// Contains the unblinded token from the mint and providers secret key
pub struct UnblindedToken {
    // Provider's secret key
    pub secret: Scalar,
    // The unblinded token from the mint
    pub proof: RistrettoPoint,
}

/// Cryptographic operations for the Provider (Alice)
pub struct ProviderCrypto {
    // the secret known to the provider
    secret: Scalar,
    // A random nonce that guarantees each mint token is unique (nonce)
    blinding_factor: Scalar,
    // The blinded message
    blinded_message: RistrettoPoint,

    ecash_token_public: RistrettoPoint,
}

impl ProviderCrypto {
    /// instantiate the struct by passing in the public key of the mint
    pub fn new(ecash_token_public: RistrettoPoint) -> Self {
        // Generate 32 cryptographically secure bytes
        let secret = Scalar::random(&mut OsRng);
        // Generate 32  cryptographically secure bytes (nonce)
        let blinding_factor = Scalar::random(&mut OsRng);
        // Run the `secret` first through a SHA512 hash and then generate a point on the elliptic curve
        let hash_to_curve_result = RistrettoPoint::hash_from_bytes::<Sha512>(secret.as_bytes());
        // Generate a `blinded_message` that is unique by adding the `hash_to_curve_result`
        // to a point on the elliptic curve generated by the multiplying the `blinding_factor` by a generator `G`
        let blinded_message =
            hash_to_curve_result + (RistrettoPoint::identity().mul(&blinding_factor));

        Self {
            secret,
            blinding_factor,
            blinded_message,
            ecash_token_public,
        }
    }

    /// Unblind a token from the mint
    pub fn unblind(&self, token: RistrettoPoint) -> UnblindedToken {
        // Performs the unblinding operation `token - blinding_factor * K` where `K` is the public key of the mint
        let proof = token.sub(self.blinding_factor.mul(self.ecash_token_public));

        UnblindedToken {
            secret: self.secret,
            proof,
        }
    }

    /// Get the unblinded token and provider secret
    pub fn blinded_message(&self) -> RistrettoPoint {
        self.blinded_message
    }
}
